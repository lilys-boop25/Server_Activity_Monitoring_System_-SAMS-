package screen;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.input.ScrollEvent;
import javafx.util.Duration;
import oshi.PlatformEnum;
import oshi.SystemInfo;
import oshi.software.os.OSProcess;
import oshi.software.os.OperatingSystem;
import oshi.util.FormatUtil;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ProcessController implements Initializable {

    @FXML
    private TreeTableView<ProcessInfo> processTable;

    @FXML
    private TreeTableColumn<ProcessInfo, String> nameCol;

    @FXML
    private TreeTableColumn<ProcessInfo, String> cpuCol;

    @FXML
    private TreeTableColumn<ProcessInfo, String> memoryCol;

    @FXML
    private TreeTableColumn<ProcessInfo, String> diskCol;

    @FXML
    private TreeTableColumn<ProcessInfo, String> networkCol;

    private SystemInfo systemInfo;
    private Timeline refreshTimeline;
    private ExecutorService executorService;
    private ObservableList<ProcessInfo> processData;
    private TreeItem<ProcessInfo> rootItem;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        systemInfo = new SystemInfo();
        executorService = Executors.newFixedThreadPool(2);
        processData = FXCollections.observableArrayList();
        
        initializeTable();
        loadProcessData();
        startAutoRefresh();
    }

    private void initializeTable() {
        // Thiết lập các cột
        nameCol.setCellValueFactory(cellData -> 
            new SimpleStringProperty(cellData.getValue().getValue().getName()));
        
        cpuCol.setCellValueFactory(cellData -> 
            new SimpleStringProperty(cellData.getValue().getValue().getCpuUsage()));
        
        memoryCol.setCellValueFactory(cellData -> 
            new SimpleStringProperty(cellData.getValue().getValue().getMemoryUsage()));
        
        diskCol.setCellValueFactory(cellData -> 
            new SimpleStringProperty(cellData.getValue().getValue().getDiskUsage()));
        
        networkCol.setCellValueFactory(cellData -> 
            new SimpleStringProperty(cellData.getValue().getValue().getNetworkUsage()));

        // Tạo root item ẩn
        rootItem = new TreeItem<>();
        rootItem.setExpanded(true);
        processTable.setRoot(rootItem);
        processTable.setShowRoot(false);

        // Thiết lập khả năng sắp xếp
        processTable.setSortMode(TreeSortMode.ALL_DESCENDANTS);
        
        // Thiết lập comparator cho các cột số
        cpuCol.setComparator(this::comparePercentage);
        memoryCol.setComparator(this::compareMemory);
        diskCol.setComparator(this::compareSize);
        networkCol.setComparator(this::compareSize);
    }

    private void loadProcessData() {
        Task<List<ProcessInfo>> loadTask = new Task<List<ProcessInfo>>() {
            @Override
            protected List<ProcessInfo> call() throws Exception {
                return fetchProcessData();
            }

            @Override
            protected void succeeded() {
                List<ProcessInfo> processes = getValue();
                Platform.runLater(() -> updateProcessTable(processes));
            }

            @Override
            protected void failed() {
                getException().printStackTrace();
            }
        };

        executorService.submit(loadTask);
    }

    private List<ProcessInfo> fetchProcessData() {
        List<ProcessInfo> processes = new ArrayList<>();
        OperatingSystem os = systemInfo.getOperatingSystem();
        long totalMemory = systemInfo.getHardware().getMemory().getTotal();
        
        List<OSProcess> osProcesses = os.getProcesses(null, null, 0);
        
        for (OSProcess process : osProcesses) {
            // Bỏ qua Idle process trên Windows
            if (process.getProcessID() == 0 && 
                SystemInfo.getCurrentPlatform().equals(PlatformEnum.WINDOWS)) {
                continue;
            }

            ProcessInfo processInfo = new ProcessInfo();
            processInfo.setName(process.getName());
            processInfo.setPid(process.getProcessID());
            processInfo.setParentPid(process.getParentProcessID());
            
            // CPU Usage
            double cpuLoad = 100.0 * process.getProcessCpuLoadBetweenTicks(null);
            processInfo.setCpuUsage(String.format("%.1f%%", cpuLoad));
            
            // Memory Usage
            long memoryUsed = process.getResidentSetSize();
            double memoryPercent = 100.0 * memoryUsed / totalMemory;
            processInfo.setMemoryUsage(FormatUtil.formatBytes(memoryUsed) + 
                " (" + String.format("%.1f%%", memoryPercent) + ")");
            
            // Disk Usage (ước tính hoặc thực tế tùy platform)
            processInfo.setDiskUsage(getDiskUsage(process));
            
            // Network Usage (ước tính)
            processInfo.setNetworkUsage(getNetworkUsage(process));
            
            // Thông tin bổ sung
            processInfo.setStatus(process.getState().name());
            processInfo.setUser(process.getUser());
            processInfo.setThreadCount(process.getThreadCount());

            processes.add(processInfo);
        }
        
        return processes;
    }

    private String getDiskUsage(OSProcess process) {
        try {
            if (SystemInfo.getCurrentPlatform().equals(PlatformEnum.WINDOWS)) {
                // Sử dụng PowerShell để lấy disk I/O
                String command = String.format(
                    "powershell \"(Get-Counter -Counter '\\Process(%s)\\IO Data Bytes/sec' -ErrorAction SilentlyContinue).CounterSamples[0].CookedValue\"",
                    process.getName().replace("'", "''")
                );
                String result = executeCommand(command);
                if (!result.trim().isEmpty()) {
                    double bytesPerSec = Double.parseDouble(result.trim());
                    return String.format("%.1f MB/s", bytesPerSec / 1024.0 / 1024.0);
                }
            }
        } catch (Exception e) {
            // Ignore và fallback
        }
        return "N/A";
    }

    private String getNetworkUsage(OSProcess process) {
        // Ước tính network usage (có thể cải thiện bằng cách sử dụng native commands)
        try {
            long openFiles = process.getOpenFiles().size();
            return String.format("%.1f KB/s", openFiles * 0.1);
        } catch (Exception e) {
            return "N/A";
        }
    }

    private String executeCommand(String command) throws Exception {
        ProcessBuilder processBuilder = new ProcessBuilder();
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            processBuilder.command("cmd.exe", "/c", command);
        } else {
            processBuilder.command("sh", "-c", command);
        }
        
        Process process = processBuilder.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        
        while ((line = reader.readLine()) != null) {
            output.append(line).append("\n");
        }
        
        process.waitFor();
        return output.toString();
    }

    private void updateProcessTable(List<ProcessInfo> processes) {
        // Lưu trạng thái mở rộng và selection hiện tại
        Set<Integer> expandedPids = new HashSet<>();
        ProcessInfo selectedProcess = null;
        
        if (processTable.getSelectionModel().getSelectedItem() != null) {
            selectedProcess = processTable.getSelectionModel().getSelectedItem().getValue();
        }

        // Xóa dữ liệu cũ
        rootItem.getChildren().clear();

        // Tạo map để tìm parent-child relationships
        Map<Integer, List<ProcessInfo>> childrenMap = new HashMap<>();
        Map<Integer, ProcessInfo> processMap = new HashMap<>();
        
        for (ProcessInfo process : processes) {
            processMap.put(process.getPid(), process);
            childrenMap.computeIfAbsent(process.getParentPid(), k -> new ArrayList<>()).add(process);
        }

        // Tạo tree structure
        List<ProcessInfo> rootProcesses = new ArrayList<>();
        for (ProcessInfo process : processes) {
            if (!processMap.containsKey(process.getParentPid()) || process.getParentPid() == 0) {
                rootProcesses.add(process);
            }
        }

        // Sắp xếp theo tên
        rootProcesses.sort(Comparator.comparing(ProcessInfo::getName, String.CASE_INSENSITIVE_ORDER));

        // Thêm vào tree
        for (ProcessInfo rootProcess : rootProcesses) {
            TreeItem<ProcessInfo> rootTreeItem = createTreeItem(rootProcess, childrenMap, processMap);
            rootItem.getChildren().add(rootTreeItem);
        }

        // Khôi phục selection nếu có
        if (selectedProcess != null) {
            restoreSelection(selectedProcess);
        }
    }

    private TreeItem<ProcessInfo> createTreeItem(ProcessInfo process, 
                                               Map<Integer, List<ProcessInfo>> childrenMap,
                                               Map<Integer, ProcessInfo> processMap) {
        TreeItem<ProcessInfo> item = new TreeItem<>(process);
        
        List<ProcessInfo> children = childrenMap.get(process.getPid());
        if (children != null && !children.isEmpty()) {
            children.sort(Comparator.comparing(ProcessInfo::getName, String.CASE_INSENSITIVE_ORDER));
            for (ProcessInfo child : children) {
                item.getChildren().add(createTreeItem(child, childrenMap, processMap));
            }
        }
        
        return item;
    }

    private void restoreSelection(ProcessInfo targetProcess) {
        // Tìm và select lại process
        findAndSelect(rootItem, targetProcess);
    }

    private boolean findAndSelect(TreeItem<ProcessInfo> item, ProcessInfo target) {
        if (item.getValue() != null && item.getValue().getPid() == target.getPid()) {
            processTable.getSelectionModel().select(item);
            return true;
        }
        
        for (TreeItem<ProcessInfo> child : item.getChildren()) {
            if (findAndSelect(child, target)) {
                return true;
            }
        }
        
        return false;
    }

    private void startAutoRefresh() {
        refreshTimeline = new Timeline(new KeyFrame(Duration.seconds(5), e -> loadProcessData()));
        refreshTimeline.setCycleCount(Timeline.INDEFINITE);
        refreshTimeline.play();
    }

    @FXML
    void setOnScrollProcess(ScrollEvent event) {
        // Xử lý scroll event nếu cần
    }

    // Comparator methods
    private int comparePercentage(String s1, String s2) {
        try {
            double d1 = Double.parseDouble(s1.replace("%", ""));
            double d2 = Double.parseDouble(s2.replace("%", ""));
            return Double.compare(d1, d2);
        } catch (NumberFormatException e) {
            return s1.compareTo(s2);
        }
    }

    private int compareMemory(String s1, String s2) {
        try {
            // Extract byte values from memory strings
            long b1 = parseMemoryString(s1);
            long b2 = parseMemoryString(s2);
            return Long.compare(b1, b2);
        } catch (Exception e) {
            return s1.compareTo(s2);
        }
    }

    private int compareSize(String s1, String s2) {
        try {
            if (s1.equals("N/A")) return s2.equals("N/A") ? 0 : -1;
            if (s2.equals("N/A")) return 1;
            
            double d1 = parseSizeString(s1);
            double d2 = parseSizeString(s2);
            return Double.compare(d1, d2);
        } catch (Exception e) {
            return s1.compareTo(s2);
        }
    }

    private long parseMemoryString(String memStr) {
        // Parse "1.2 MB (0.5%)" format
        String[] parts = memStr.split(" \\(");
        if (parts.length > 0) {
            String sizePart = parts[0].trim();
            return parseBytesFromFormatUtil(sizePart);
        }
        return 0;
    }

    private long parseBytesFromFormatUtil(String sizeStr) {
        String[] parts = sizeStr.split(" ");
        if (parts.length == 2) {
            double value = Double.parseDouble(parts[0]);
            String unit = parts[1];
            switch (unit) {
                case "bytes": return (long) value;
                case "KiB": return (long) (value * 1024);
                case "MiB": return (long) (value * 1024 * 1024);
                case "GiB": return (long) (value * 1024 * 1024 * 1024);
            }
        }
        return 0;
    }

    private double parseSizeString(String sizeStr) {
        if (sizeStr.contains("MB/s")) {
            return Double.parseDouble(sizeStr.replace(" MB/s", ""));
        } else if (sizeStr.contains("KB/s")) {
            return Double.parseDouble(sizeStr.replace(" KB/s", "")) / 1024.0;
        }
        return 0;
    }

    public void cleanup() {
        if (refreshTimeline != null) {
            refreshTimeline.stop();
        }
        if (executorService != null) {
            executorService.shutdown();
        }
    }

    // Inner class to hold process information
    public static class ProcessInfo {
        private String name;
        private String cpuUsage;
        private String memoryUsage;
        private String diskUsage;
        private String networkUsage;

        // Constructors
        public ProcessInfo() {}

        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getCpuUsage() { return cpuUsage; }
        public void setCpuUsage(String cpuUsage) { this.cpuUsage = cpuUsage; }

        public String getMemoryUsage() { return memoryUsage; }
        public void setMemoryUsage(String memoryUsage) { this.memoryUsage = memoryUsage; }

        public String getDiskUsage() { return diskUsage; }
        public void setDiskUsage(String diskUsage) { this.diskUsage = diskUsage; }

        public String getNetworkUsage() { return networkUsage; }
        public void setNetworkUsage(String networkUsage) { this.networkUsage = networkUsage; }
    }
}